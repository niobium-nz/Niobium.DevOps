parameters:
- name: serviceConnectionId
  type: string
- name: azureServiceConnection
  type: string
- name: resourceGroupName
  type: string
- name: appNamePrefix
  type: string
- name: buildAgentVmImage
  type: string
  default: 'windows-latest'
- name: checkoutDevopsStep
  type: step
  default:
    script: echo dummy step
- name: enableKeyVault
  type: boolean
  default: false
- name: enableStagingSlot
  type: boolean
  default: false
- name: customDomainName
  type: string
  default: ''
- name: functionRuntime
  type: string
  default: 'dotnet-isolated'

jobs:
- job: Infrastructure
  pool:
    vmImage: 'windows-2019'
  steps:
  - ${{ parameters.checkoutDevopsStep }}

  - task: AzureResourceManagerTemplateDeployment@3
    displayName: 'Infrastructure Provisioning'
    inputs:
      deploymentScope: 'Resource Group'
      azureResourceManagerConnection: ${{ parameters.azureServiceConnection }}
      action: 'Create Or Update Resource Group'
      resourceGroupName: ${{ parameters.resourceGroupName }}
      location: '$(location)'
      templateLocation: 'Linked artifact'
      csmFile: '$(Build.SourcesDirectory)/bicep/FunctionApp.bicep'
      overrideParameters: >-
        -appNamePrefix ${{ parameters.appNamePrefix }}
        -enableKeyVault ${{ convertToJson(parameters.enableKeyVault) }}
        -enableStagingSlot ${{ convertToJson(parameters.enableStagingSlot) }}
        -customDomainName ${{ parameters.customDomainName }}
        -runtime ${{ parameters.functionRuntime }}
      deploymentMode: 'Incremental'
      deploymentName: 'DeployPipelineTemplate'
      deploymentOutputs: 'infrastructureProvisioningResult'

  - template: ../steps/parseBicepResult.yml
    parameters:
      inputJSONValue: '$(infrastructureProvisioningResult)'
      outputVariableName: 'infrastructureOutputs'

- deployment: Deploy
  displayName: Deploy
  dependsOn: Infrastructure
  condition: succeeded()
  environment: 'production'
  pool:
    vmImage: 'windows-2019'
  variables:
    functionAppName: $[ dependencies.Infrastructure.outputs['infrastructureOutputs.functionAppName'] ]  

  strategy:
    runOnce:
      deploy:
        steps: 
        - pwsh: Write-Output "##vso[task.setvariable variable=slotName;]production"
          displayName: "Deploy to Production"
          condition: eq('${{ parameters.enableStagingSlot }}', false)

        - pwsh: Write-Output "##vso[task.setvariable variable=slotName;]staging"
          displayName: "Deploy to Staging"
          condition: eq('${{ parameters.enableStagingSlot }}', true)

        - task: AzureFunctionApp@2
          displayName: 'Functions Deploy'
          inputs:
            azureSubscription: ${{ parameters.serviceConnectionId }}
            resourceGroupName: ${{ parameters.resourceGroupName }}
            appType: functionApp
            appName: $(functionAppName)
            slotName: $(slotName)
            deployToSlotOrASE: ${{ parameters.enableStagingSlot }}
            package: '$(Pipeline.Workspace)/drop/function-app-$(Build.BuildNumber).zip'

        - task: AzureAppServiceManage@0
          displayName: 'Swap to Production'
          condition: and(succeeded(), eq('${{ parameters.enableStagingSlot }}', true))
          inputs:
            azureSubscription: ${{ parameters.serviceConnectionId }}
            ResourceGroupName: ${{ parameters.resourceGroupName }}
            WebAppName: $(functionAppName)
            SourceSlot: staging
            SwapWithProduction: true